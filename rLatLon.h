#ifndef rLatLonhh#define rLatLonhh#include "rVector.h"#include <math.h>#include <ostream>#include <iostream>/* * Forward class declarations */class rLatLon;class rLatLonint;class Rect2D;class rPoint2D;class rVector;class Trixel;#ifndef PI#define PI		3.141596654#endif#define RADTODEG	180.0/PI#define DEGTORAD	PI/180.0/* * Class declarations */class rLatLon {  friend std::ostream& operator<<(std::ostream&, rLatLon&); /* used with cout */  protected:  public:    double lat,lon;    rLatLon () {};    rLatLon (rLatLon &) {};    rLatLon (int i,int j) {lon = (double)i; lat = (double)j;}    rLatLon (double i,double j) {lon = i; lat = j;}    rLatLon &operator=(rLatLon );    rLatLon &operator=(rLatLonint );    rLatLon &operator=(rPoint2D );        operator int();    operator double();    operator rPoint2D ();    operator rVector ();    operator rLatLonint ();        int rint (double num) { return (int) num; }    int operator==(rLatLon p) {  // account for round off in comparision.     //cerr <<"rLatLon::==:"<<(int)lon<<"=="<<(int)p.lon<<"&&"<<(int)lat<<"=="<<(int)p.lat<<"  "<<(int)((int)lon == (int)p.lon && (int)lat == (int)p.lat )<<"  "<<(int)(lon==p.lon)<<"  "<<(int)(lat==p.lat)<<endl;       return (rint(lon*10.0) == rint(p.lon*10.0) && rint(lat*10.0) == rint(p.lat*10.0) );}    int operator<=(rLatLon p) { return (lon<=p.lon && lat<=p.lat); }    int operator<(rLatLon p) { return (lon<p.lon && lat<p.lat); }    int operator>=(rLatLon p) { return (lon>=p.lon && lat>=p.lat); }    int operator>(rLatLon p) { return (lon>p.lon && lat>p.lat); }  /*  friend Rect2D;    friend Trixel;    friend rVector;*/};#endif