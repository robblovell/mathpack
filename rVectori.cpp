//#include <iostream.h>#include <math.h>#include "rPointi.h"#include "rVectori.h"#include "rVector.h"//rVectori::operator vector () { rVector p((double)x,(double)y,(double)z); return p; }/* * Class declaration^ */rVectori::rVectori(rPointi p)  : rPointi (p){ }rVectori::rVectori(rVectori &p)  : rPointi (p.x,p.y,p.z){ }rVectori::rVectori(rPointi A,rPointi B)  : rPointi (B.x-A.x,B.y-A.y,B.z-A.z){ }/*rVectori::operator rPointi (){  rPointi c(x,y,z);  return c;}*//*	Cross Product */rVectori rVectori::operator*(rVectori b){  rVectori c;  c.x = y*b.z-z*b.y;  c.y = z*b.x-x*b.z;  c.z = x*b.y-y*b.x;  return (c);}rVectori rVectori::operator*=(rVectori b){  rVectori c;  c.x = y*b.z-z*b.y;  c.y = z*b.x-x*b.z;  c.z = x*b.y-y*b.x;  *this = c;  return (*this);}/*	ScalerVectori rVectori::operator*(int b){  rVectori c;  c.x = c.x*b;  c.y = c.y*b;  c.z = c.z*b;  return (c);}rVectori rVectori::operator/(int b){  rVectori c;  c.x = c.x/b;  c.y = c.y/b;  c.z = c.z/b;  return (c);} */rVectori rVectori::cross(rVectori b){  rVectori c;  c.x = y*b.z-z*b.y;  c.y = z*b.x-x*b.z;  c.z = x*b.y-y*b.x;  return c;}/*	Dot Product */int rVectori::operator|(rVectori b){  return (x*b.x+y*b.y+z*b.z);}int rVectori::dot(rVectori u){  return (x*u.x+y*u.y+z*u.z);}/* 	One rVector divided by another. */rVectori rVectori::operator/(rVectori b){  rVectori c (x/b.x,y/b.y,z/b.z);  return (c);}/*        Add rVectors by scalars. */rVectori operator+(int a,rVectori b){  rVectori c(a+b.x,a+b.y,a+b.z);  return c;}rVectori operator+(rVectori b,int a){  rVectori c(a+b.x,a+b.y,a+b.z);  return c;}/*        Subtract rVectors by scalars. */rVectori operator-(int a,rVectori b){  rVectori c(a-b.x,a-b.y,a-b.z);  return c;}rVectori operator-(rVectori b,int a){  rVectori c(a-b.x,a-b.y,a-b.z);  return c;}/*        Multiply rVectors by scalars. */rVectori operator*(int a,rVectori b){  rVectori c(a*b.x,a*b.y,a*b.z);  return c;}rVectori operator*(rVectori b,int a){  rVectori c(a*b.x,a*b.y,a*b.z);  return c;}/*        Divide rVectors by scalars. */rVectori operator/(int a,rVectori b){  rVectori c(a/b.x,a/b.y,a/b.z);  return c;}rVectori operator/(rVectori b,int a){  rVectori c(a/b.x,a/b.y,a/b.z);  return c;}/*        Dot two rVectors. *//*int operator|(rVectori &a,rVectori &b){  return (a.x*b.x+a.y*b.y+a.z*b.z);}*//* 	One rVector divided by another. *//*rVectori operator/(rVectori &a,rVectori &b){  rVectori c (a.x/b.x,a.y/b.y,a.z/b.z);  return (c);}*//*	Add two rVectors */rVectori operator+(rVectori a,rVectori b){  rVectori c(a.x+b.x,a.y+b.y,a.z+b.z);  return c;}/*        Subtract two rVectors. */rVectori operator-(rVectori a,rVectori b){  rVectori c(a.x-b.x,a.y-b.y,a.z-b.z);  return c;}rVectori& rVectori::operator*=(int s){  x *= s; y *= s; z *= s;  return (*this);}rVectori& rVectori::operator/=(int s){  x /= s; y /= s; z /= s;  return (*this);}rVectori& rVectori::operator+=(int s){  x += s; y += s; z += s;  return (*this);}rVectori& rVectori::operator+=(rVectori b){  x += b.x; y += b.y; z += b.z;  return (*this);}rVectori& rVectori::operator-=(rVectori b){  x -= b.x; y -= b.y; z -= b.z;  return (*this);}rVectori& rVectori::operator-=(int s){  x -= s; y -= s; z -= s;  return (*this);}int rVectori::is_acute_with (rVectori &v){  return (angle_with (v)==-1);}int rVectori::is_obtuse_with (rVectori &v){  return (angle_with (v)==1);}/*   this function determines whether the angle between two rVectors is acute,   obtuse, or 180 degrees.  acuteness depends upon the direction of the cross    product in relation to the two rVectors. */int rVectori::angle_with (rVectori &v){  rVectori cp;cp = *this*v;  int thesin_plus = cp.magnitude ();  cp = v* *this;  int thesin_neg = cp.magnitude ();  int thedot = this->dot (v);  if (thedot == 1) return -1;  if (thesin_plus == 0) return 0;  if (thedot < 0) {    if (thesin_plus < thesin_neg) return 1; // obtuse angle    else if (thesin_plus > thesin_neg) return -1; // acute angle    else return 0;// colinear  }  else if (thedot > 0) {    if (thesin_plus > thesin_neg) return 1; // obtuse angle    else if (thesin_plus < thesin_neg) return -1; // acute angle    else return 0; //colinear  }  else {    /* perturb one of the rVectors a little to make them not perpendicular, then	do the test again.     */    rVectori tmp((int)((v.x+x)/2.0),(int)((v.y+y)/2.0),(int)((v.z+z)/2.0));    return angle_with (tmp);  }}int rVectori::angle_with (rVectori &v,rVectori &cp,rVectori &cn){  int thesin_plus = cp.magnitude ();  int thesin_neg = cn.magnitude ();  int thedot = this->dot (v);  if (thedot == 1) return -1;  if (thesin_plus == 0) return 0;  if (thedot < 0) {    if (thesin_plus < thesin_neg) return 1; // obtuse angle    else if (thesin_plus > thesin_neg) return -1; // acute angle    else return 0;// colinear  }  else if (thedot > 0) {    if (thesin_plus > thesin_neg) return 1; // obtuse angle    else if (thesin_plus < thesin_neg) return -1; // acute angle    else return 0; //colinear  }  else {    /* perturb one of the rVectors a little to make them not perpendicular, then	do the test again.     */    rVectori tmp((int)((v.x+x)/2.0),(int)((v.y+y)/2.0),(int)((v.z+z)/2.0));    return angle_with (tmp);  }}int rVectori::angle_with (rVectori &v,int &thesin_plus,int &thesin_neg,int &thedot){  if (thedot == 1) return -1;  if (thesin_plus == 0) return 0;  if (thedot < 0) {    if (thesin_plus < thesin_neg) return 1; // obtuse angle    else if (thesin_plus > thesin_neg) return -1; // acute angle    else return 0;// colinear  }  else if (thedot > 0) {    if (thesin_plus > thesin_neg) return 1; // obtuse angle    else if (thesin_plus < thesin_neg) return -1; // acute angle    else return 0; //colinear  }  else {    /* perturb one of the rVectors a little to make them not perpendicular, then	do the test again.     */    rVectori tmp((int)((v.x+x)/2.0),(int)((v.y+y)/2.0),(int)((v.z+z)/2.0));    return angle_with (tmp);  }}