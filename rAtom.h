/* File: $RCSfile: Atom.hh,v $ *  * Synopsis: *  * Notes:  * * * ------------------------------------------------------------------------- * IIFS - Intelligent Information Fusion System *                                                                         * Contact: Robb Lovell (lovell@tucson.gsfc.nasa.gov)  or    *          Greg Sylvain (sylvain@tucson.gsfc.nasa.gov) * Intelligent Data Management Group                                       * Information Science and Technology Office                               * Code 930.1                                                              * NASA Goddard Space Flight Center                                        * Greenbelt, MD 20771                                                     *                                                                         * ------------------------------------------------------------------------- * *				NOTICE *				------ * *  Permission to use this software is granted subject to the following *  restrictions and understandings: *   *  Sponsor:  	National Aeronautics and Space Administration (NASA) *		Goddard Space Flight Center (GSFC) *		Intelligent Data Management Group *		Information Sciences and Technology Office (ISTO) *		Code 930.1, Greenbelt, MD 20771 * * *  Author:	Robb E. Lovell *		Hughes/STX *		Goddard Space Flight Center (GSFC) *		Code 930.1, Greenbelt, MD 20771		 *		 *  This Software may be freely used and distributed without any *  compensation to the author or the sponsor.  It is provided without *  support and without any obligation, whatsoever, to assist in its use, *  correction, modification or enhancement. * *  THIS SOFTWARE IS PROVIDED "AS IS" WITH NO EXPRESS OR IMPLIED *  WARRANTIES OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY OR *  FITNESS FOR A PARTICULAR PURPOSE.  There is no warranty that this *  software will meet any particular specification nor is there any *  warranty that the documentation providing instructions or information *  for use of the software is accurate or otherwise conforms to the *  software requirements.  Further, in furnishing this software, there *  shall be no liability, under any circumstances, for either direct or *  consequential damages. * *  Any user of this software agrees that they will repeat this Notice in *  its entirety, prior to the distribution of this software to another. *  Likewise, all materials and reports developed as a consequence of the *  use of this software shall duly acknowledge such use, in accordance *  with the usual standards of acknowledging credit in *  academic/Government research. * *------------------------------------------------------------------------- *//*-------------------------------------------------------------------------- | $Log: Atom.hh,v $ | Revision 1.3  1994/01/15  22:52:22  sylvain | updated the includes to include the shorter filenames | | Revision 1.2  1994/01/15  17:13:50  iifs | initial modifications to the iifs database that was redesign for code 930.2 | | Revision 1.1  1993/11/02  21:37:31  iifs | Initial revision | +-------------------------------------------------------------------------*/#ifdef Commentstatic char rcsid[] ="$Id: Atom.hh,v 1.3 1994/01/15 22:52:22 sylvain Exp $";#endif/* @@ */#ifndef Atomhh#define Atomhh#include <ostore/ostore.hh>#include <iostream.h>#include <fstream.h>#include "IifsString.hh"#include "LitIifsStr.hh"#include "DateIifsStr.hh"#include "TimeIifsStr.hh"#include "Date.hh"#include "format.hh"#include "Time.hh"#include "rLatLon.hh"#include "rPoint.hh"#include "rVector.hh"#include "Rect.hh"#include "rPoint2D.hh"#include "rLine2D.hh"#include "Rect2D.hh"#include "Circle2D.hh"#include "Trixel2D.hh"#include "Trixel.hh"#include "Poly.hh"#include "Poly2D.hh"#include "Logical.hh"#include "Range.hh"extern os_typespec *CHAR;extern os_typespec *INT;extern os_typespec *DOUBLE;extern os_typespec *VOIDPTR;class Atom;/* * Class declarations *//* 	The fields in AtomTYPE must be in the same order as the objects    that are declared in the union in the Atom class.*/enum AtomTYPE{   Null_=0,int_,double_,char_,   IifsString_,LitIifsString_,   format_,Date_,Time_,   rPoint_,rVector_,Rect_,Trixel_,Poly_,   rPoint2D_,rLine2D_,Rect2D_,Circle2D_,Trixel2D_,Poly2D_,   rLatLon_,Range_,   Logical_};class Atom{  protected:  public:    struct Arefer {      union {        int *i; double *d; char *c;         IifsString *str; LitIifsString *s;        format *ft;        Date *dt; Time *t;        rPoint *pt; rVector *v; Rect *rect; Trixel *tri; Poly *poly;        rPoint2D *p; rLine2D *l; Rect2D *r; Circle2D *ci; Trixel2D *tr; Poly2D *ply;	     rLatLon *ll; Range *ra;	     Logical *logic;      };      int ref;      AtomTYPE type;      Arefer () {ref = 1;type = Null_;}      ~Arefer () {deletefields ();}      void deletefields () {        switch (type) {          case int_: delete i; break;          case double_: delete d; break;          case char_: delete c; break;          case LitIifsString_: delete s; break; 	  case IifsString_: delete str; break; 	  case rPoint_: delete pt; break; 	  case rVector_: delete v; break; 	  case Rect_: delete rect; break; 	  case Trixel_: delete tri; break; 	  case Poly_: delete poly; break; 	  case Poly2D_: delete ply; break; 	  case Trixel2D_: delete tr; break; 	  case rPoint2D_: delete p; break; 	  case rLatLon_: delete ll; break; 	  case Rect2D_: delete r; break; 	  case Range_: delete ra; break; 	  case rLine2D_: delete l; break; 	  case Circle2D_: delete ci; break;          case Date_: delete dt; break;          case format_: delete ft; break;	  case Time_: delete t; break;          case Logical_: delete logic; break;          case Null_: break;        }      }    };    Arefer *com;    AtomTYPE typeof () { return com->type; }    // constructors.    Atom () {com = new Arefer(); com->type = Null_;}    // Constructors continued... Wow, a lot 'o' constructors!!!    Atom (int& t) {com = new Arefer(); com->i=new int(t);com->type = int_;}    Atom (double &t) {com = new Arefer(); com->d=new double(t);com->type = double_;}    Atom (char &t) {com = new Arefer(); com->c=new char(t);com->type = char_;}    Atom (const char *t) {com = new Arefer(); com->s=new LitIifsString(t);com->type = LitIifsString_;}    Atom (LitIifsString t) {com = new Arefer(); com->s=new LitIifsString(t);com->type = LitIifsString_;}    Atom (IifsString t) {com = new Arefer(); com->str=new IifsString(t);com->type = IifsString_;}    Atom (Time t) {com = new Arefer(); com->t=new Time(t);com->type = Time_;}    Atom (rPoint t) {com = new Arefer(); com->pt=new rPoint(t);com->type = rPoint_;}    Atom (rVector t) {com = new Arefer(); com->v=new rVector(t);com->type = rVector_;}    Atom (Rect t) {com = new Arefer(); com->rect=new Rect(t);com->type = Rect_;}    Atom (Trixel t) {com = new Arefer(); com->tri=new Trixel(t);com->type = Trixel_;}    Atom (Poly t) {com = new Arefer(); com->poly=new Poly(t);com->type = Poly_;}    Atom (Poly2D t) {com = new Arefer(); com->ply=new Poly2D(t);com->type = Poly2D_;}    Atom (Trixel2D t) {com = new Arefer(); com->tr=new Trixel2D(t);com->type = Trixel2D_;}    Atom (rPoint2D t) {com = new Arefer(); com->p=new rPoint2D(t);com->type = rPoint2D_;}    Atom (rLatLon t) {com = new Arefer(); com->ll=new rLatLon(t);com->type = rLatLon_;}    Atom (rLine2D t) {com = new Arefer(); com->l=new rLine2D(t);com->type = rLine2D_;}    Atom (Circle2D t) {com = new Arefer(); com->ci=new Circle2D(t);com->type = Circle2D_;}    Atom (Rect2D t) {com = new Arefer(); com->r=new Rect2D(t);com->type = Rect2D_;}    Atom (Range &t) {com = new Arefer(); com->ra=new Range(t);com->type = Range_;}    Atom (Date &t) {com = new Arefer(); com->dt=new Date(t);com->type = Date_;}    Atom (Logical &t) {com = new Arefer(); com->logic=new Logical(t);com->type = Logical_;}    Atom (format &t) {com = new Arefer(); com->ft=new format(t);com->type = format_;}    void Null () {com = new Arefer(); com->type = Null_;}    Atom (Atom &);    Atom (const Atom &);    ~Atom();    int discriminant ();    void dout ();    // operators    int operator==(const Atom&);    int operator!=(const Atom&);    int operator<=(const Atom&);    int operator>=(const Atom&);    int operator<(const Atom&);    int operator>(const Atom&);    int operator==(const int& val)      { return (/*com->type == int_ &&*/ *(com->i) == (int)val);}    int operator==(const double& val)      { return (/*com->type == double_ &&*/ *(com->d) == (double)val);}    friend int operator==(const Atom& a, const char& val)      { return (a.com->type == char_ && *(a.com->c) == val);}    friend int operator==(const Atom& a, const format& val)      { return (a.com->type == format_ && *(a.com->ft) == val);}/*    friend int operator==(const Atom& a, const Date& val)      { return (a.com->type == Date_ && *(a.com->dt) == val);}*/    int operator==(const Logical& val)      { return (com->type == Logical_ && *(com->logic) == val);}    int operator==(const LitIifsString& val)      { return ((com->type == IifsString_ || com->type == LitIifsString_) && *(com->s) == val);}    int operator==(const IifsString& val)      { return ((com->type == IifsString_ || com->type == LitIifsString_) && *(com->s) == val); }    int operator==( Trixel& val)      { return (com->type == Trixel_ && *(com->tri) == val);}    int operator==(const Trixel2D& val)      { return (com->type == Trixel2D_ && *(com->tr) == val);}    int operator==(Poly &val)      { if (com->type == Poly_) return val ==  *(com->poly);         else return 0;      }    int operator==( Poly2D& val)      { return (com->type == Poly2D_ && *(com->ply) == val);}    int operator==(const Time& val)      { return (com->type == Time_ && *(com->t) == val);}    int operator==(const rPoint& val)      { return (com->type == rPoint_ && *(com->pt) == val);}    int operator==( rVector& val)      { return (com->type == rVector_ && *(com->v) == val);}    int operator==( Rect& val)      { return (com->type == Rect_ && *(com->rect) == val);}    int operator==(const rPoint2D& val)      { return (com->type == rPoint2D_ && *(com->p) == val);}    int operator==(const rLatLon& val)      { return (com->type == rLatLon_ && *(com->ll) == val);}    int operator==(const rLine2D& val)      { return (com->type == rLine2D_ && *(com->l) == val);}    int operator==(const Rect2D& val)      { return (com->type == Rect2D_ && *(com->r) == val);}    int operator==(Range& val)      { if (com->type == Range_) return *(com->ra) == val;        else return 0;}    int operator==(const Circle2D& val)      { return (com->type == Circle2D_ && *(com->ci) == val);}    Atom& operator=(const Atom&);    Atom& operator=(Atom&);    Atom& operator=(int&);    Atom& operator=(double&);    Atom& operator=(char&);    Atom& operator=(const char *);    Atom& operator=(LitIifsString&);    Atom& operator=(IifsString&);    Atom& operator=(Time&);    Atom& operator=(rPoint&);    Atom& operator=(rVector&);    Atom& operator=(Rect&);    Atom& operator=(Trixel&);    Atom& operator=(Trixel2D&);    Atom& operator=(Poly&);    Atom& operator=(Poly2D&);    Atom& operator=(rLine2D&);    Atom& operator=(rPoint2D&);    Atom& operator=(rLatLon&);    Atom& operator=(Rect2D&);    Atom& operator=(Range&);    Atom& operator=(Circle2D&);    Atom& operator=(Date&);    Atom& operator=(Logical&);    Atom& operator=(format&);    Atom& copy(Atom&);    void atomcopy(Atom&,Atom&);    // Conversion    operator int();     operator double();     operator char();     operator char *();     operator const char *();     operator IifsString();     operator LitIifsString();     operator Time ();    operator rPoint();    operator rVector();    operator Rect();    operator Trixel();    operator Trixel2D();    operator Poly();    operator Poly2D();    operator rPoint2D();    operator rLatLon();    operator rLine2D();    operator Rect2D();    operator Range();    operator Circle2D();    operator Date();     operator Logical();     operator format();     // Display...    friend ostream& operator<<(ostream&, Atom&);    // Field Specific Access.    int day () { if (com && com->type == Date_) return (com->dt->day());                   else return (-1);}    int month () { if (com && com->type == Date_) return (com->dt->month());                   else return (-1);}    int year () { if (com && com->type == Date_) return (com->dt->year());                   else return (-1);}    int second () { if (com && com->type == Time_) return (com->t->second());                   else return (-1);}    int minute () { if (com && com->type == Time_) return (com->t->minute());                   else return (-1);}    int hour () { if (com && com->type == Time_) return (com->t->hour());                   else return (-1);}    int min () { if (com && com->type == Range_) return ((int)com->ra->min);		  else return (-1);}    int max () { if (com && com->type == Range_) return ((int)com->ra->max);		  else return (-1);}    };//--------------------------------------------------------------------------------------------/*	Conversion. */#endif