//#include <iostream.h>#include "rPoint.h"#include "rVector.h"#include "rPoint2D.h"#include "rLatLon.h"#include "rLatLonint.h"#include <math.h>using std::ios;/* * Class declarations */rLatLon &rLatLon::operator=(rLatLonint p){  lon = (long)((double)p.lon/PRECISION);  lat = (long)((double)p.lat/PRECISION);  return (*this);}rLatLon &rLatLon::operator=(rPoint2D p){/*  double lon,lat;  lon = p.x*RADTODEG;  lat = p.y*RADTODEG;  lonmin = (int)lon;  latmin = (int)lat;  lonsec = (int)((double)(lon-(int)lon)*100.0);  latsec = (int)((double)(lat-(int)lat)*100.0);*/  lon = p.x*RADTODEG;  lat = p.y*RADTODEG;    return (*this);}rLatLon &rLatLon::operator=(rLatLon p){  lon = p.lon;  lat = p.lat;  return (*this);}rLatLon::operator rVector (){  //   From rLatLon to rVector....  // Assumes rLatLon is on a unit sphere.  rVector p;  p = *this;  return p;}rLatLon::operator rPoint2D(){	rPoint2D v;	v = *this;	return v;}rLatLon::operator rLatLonint(){  rLatLonint p;	p = *this;  return p;}rLatLon::operator int(){  int p;  p = (int)(double)lon;  return p;} rLatLon::operator double(){  double p;  p = (double)lon*PI/180.0;  return p;}ostream& operator<<(ostream& os, rLatLon& p){  os << '('<<"rLatLon::";  os.setf(ios::fixed|ios::showbase|ios::showpoint);  os << (double)p.lat ; /* lattitude is first!!! */  os <<','<<(double)p.lon;  os << ')';  return os;}