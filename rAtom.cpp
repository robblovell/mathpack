/* File: $RCSfile: Atom.cc,v $ *  * Synopsis: *  * Notes:  * * * ------------------------------------------------------------------------- * IIFS - Intelligent Information Fusion System *                                                                         * Contact:    Greg Sylvain (sylvain@tucson.gsfc.nasa.gov) * Intelligent Data Management Group                                       * Information Science and Technology Office                               * Code 930.1                                                              * NASA Goddard Space Flight Center                                        * Greenbelt, MD 20771                                                     *                                                                         * ------------------------------------------------------------------------- * *				NOTICE *				------ * *  Permission to use this software is granted subject to the following *  restrictions and understandings: *   *  Sponsor:  	National Aeronautics and Space Administration (NASA) *		Goddard Space Flight Center (GSFC) *		Intelligent Data Management Group *		Information Sciences and Technology Office (ISTO) *		Code 930.1, Greenbelt, MD 20771 * * *  Author:	Intelligent Data Management Applied Research Group *		Hughes/STX *		Goddard Space Flight Center (GSFC) *		Code 930.1, Greenbelt, MD 20771		 *		 *  This Software may be freely used and distributed without any *  compensation to the author or the sponsor.  It is provided without *  support and without any obligation, whatsoever, to assist in its use, *  correction, modification or enhancement. * *  THIS SOFTWARE IS PROVIDED "AS IS" WITH NO EXPRESS OR IMPLIED *  WARRANTIES OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY OR *  FITNESS FOR A PARTICULAR PURPOSE.  There is no warranty that this *  software will meet any particular specification nor is there any *  warranty that the documentation providing instructions or information *  for use of the software is accurate or otherwise conforms to the *  software requirements.  Further, in furnishing this software, there *  shall be no liability, under any circumstances, for either direct or *  consequential damages. * *  Any user of this software agrees that they will repeat this Notice in *  its entirety, prior to the distribution of this software to another. *  Likewise, all materials and reports developed as a consequence of the *  use of this software shall duly acknowledge such use, in accordance *  with the usual standards of acknowledging credit in *  academic/Government research. * *------------------------------------------------------------------------- *//*-------------------------------------------------------------------------- | $Log: Atom.cc,v $ | Revision 1.3  1994/01/15  22:50:00  sylvain | appended the rcs header and updated the includes. | | Revision 1.2        94/01/15 17:13:50     iifs | initial modifications to the iifs database that was redesign for code 930.2 |  | Revision 1.1        93/11/02 21:03:59     iifs | Initial revision | +-------------------------------------------------------------------------*///#include <ostore/ostore.h>//#include <ostore/coll.h>#include <iostream>#include <fstream>#include <string.h>#include <strstream>//#include "common.h"//#include "IifsString.h"//#include "LitIifsStr.h"//#include "format.h"//#include "Date.h"//#include "Logical.h"#include "Time.h"#include "rLatLon.h"#include "rPoint.h"#include "rVector.h"//#include "Rect.h"#include "rPoint2D.h"//#include "Range.h"#include "rLine2D.h"//#include "Rect2D.h"//#include "Circle2D.h"//#include "Trixel2D.h"//#include "Trixel.h"//#include "Poly2D.h"//#include "Poly.h"//#include "Atom.h"/* * Class declarations */os_typespec *CHAR = new os_typespec("char");os_typespec *INT = new os_typespec("int");os_typespec *DOUBLE = new os_typespec("double");os_typespec *AREFER = new os_typespec ("Arefer");//--------------------------------------------------------------------------------------------/*	Conversion. */Atom::operator int() {  int i;  if (com->type == int_)    i = *(com->i);  else if (com->type == double_)    i = (int) *(com->d);  else i=0;  //cout <<"Atom::(int):"<<i<<"  "<<com->type<<'\n'<<flush;  return i;}Atom::operator double() {  double d;  if (com->type == int_)    d = (double)*(com->i);  else if (com->type == double_)    d = *(com->d);  else d=0.0;  //cout <<"Atom::(double):"<<d<<" "<<com->type<<'\n'<<flush;  return d;}Atom::operator char() {  return *(com->c);}Atom::operator char *() {     char *c=NULL;    if (com->type == LitIifsString_)      c = (char *)*(com->s);    else if (com->type == IifsString_)      c = (char *)*(com->str);    else if (com->type == char_)      c = (char *)(com->str->com->s);     return c;}Atom::operator const char *() {     char *c=NULL;    if (com->type == LitIifsString_)      c = (char *)*(com->s);    else if (com->type == IifsString_)      c = (char *)*(com->str);    else if (com->type == char_)      c = (char *)(com->str->com->s);     return c;}Atom::operator IifsString() {  if (com->type == LitIifsString_)    return *(com->s);  else if (com->type == IifsString_)    return *(com->str);  return *(com->str);}Atom::operator LitIifsString() {  if (com->type == LitIifsString_)    return *(com->s);  else if (com->type == IifsString_)    return *(com->str);  return *(com->s);}Atom::operator format() {  return *(com->ft);}Atom::operator Date() {  return *(com->dt);}Atom::operator Logical() {  return *(com->logic);}Atom::operator Time() {  return *(com->t);}Atom::operator rPoint() {  return *(com->pt);}Atom::operator rVector() {  return *(com->v);}Atom::operator Rect() {  return *(com->rect);}Atom::operator Trixel() {  return *(com->tri);}Atom::operator Trixel2D() {  return *(com->tr);}Atom::operator Poly() {  return *(com->poly);}Atom::operator Poly2D() {  return *(com->ply);}Atom::operator rPoint2D() {  return *(com->p);}Atom::operator rLatLon () {  return *(com->ll);}Atom::operator rLine2D() {  return *(com->l);}Atom::operator Rect2D() {  return *(com->r);}Atom::operator Range() {  return *(com->ra);}Atom::operator Circle2D() {  return *(com->ci);}//--------------------------------------------------------------------------------------------/*	Constructors. */Atom::Atom (const Atom &p) {  p.com->ref++;  com = p.com;}Atom::Atom (Atom &p) {  p.com->ref++;  com = p.com;}Atom::~Atom () {  //cerr <<"delete atom!"<<endl;  if (--com->ref == 0) {    //cerr <<"delete atom's com...\n";    com->deletefields ();    delete com;  }}int Atom::discriminant () {   return (int)com->type; }//--------------------------------------------------------------------------------------------/*   IO...   display... */ostream& operator<<(ostream& os, Atom& p) {   if (p.com) {    switch ((int)p.com->type) {      case int_: os <<*(p.com->i); break;      case double_: os <<*(p.com->d); break;      case char_: os <<*(p.com->c); break;      case LitIifsString_: os <<*(p.com->s); break;      case IifsString_: os <<*(p.com->str); break;      case Time_: os <<*(p.com->t); break;      case rPoint_: os <<*(p.com->pt); break;      case rVector_: os <<*(p.com->v); break;      case Rect_: os <<*(p.com->rect); break;      case Trixel_: os <<*(p.com->tri); break;      case Trixel2D_: os <<*(p.com->tr); break;      case Poly_: os <<*(p.com->poly); break;      case Poly2D_: os <<*(p.com->ply); break;      case rPoint2D_: os <<*(p.com->p); break;      case rLatLon_: os <<*(p.com->ll); break;      case rLine2D_: os <<*(p.com->l); break;      case Rect2D_: os <<*(p.com->r); break;      case Range_: os <<*(p.com->ra); break;      case Circle2D_: os <<*(p.com->ci); break;      case format_: os <<*(p.com->ft); break;      case Date_: os <<*(p.com->dt); break;      case Logical_: os <<*(p.com->logic); break;      case Null_: os <<"Null_"; break;    }  }  else {      os <<"Atom::ostream:NULL";   }  return os; } /* used with cout *///-----------------------------------------------------------------------------/*   Operators... */int Atom::operator==(const Atom& p){  if (p.com) {    switch (com->type) {      case int_: if (*(com->i)==*(p.com->i)) return 1; break;      case double_: if (*(com->d)==*(p.com->d)) return 1; break;      case char_: if (*(com->c)==*(p.com->c)) return 1; break;      case LitIifsString_:           if (p.com->type == LitIifsString_)  return *(com->s)==*(p.com->s);          else if (p.com->type == IifsString_) return *(com->s)==*(p.com->str);          return 0;      case IifsString_:           if (p.com->type == IifsString_)  return *(com->str)==*(p.com->str);          else if (p.com->type == LitIifsString_) return *(com->str)==*(p.com->s);          return 0;      case Date_: if (*(com->dt)==*(p.com->dt)) return 1; break;      case Logical_: if (*(com->logic)==*(p.com->logic)) return 1; break;      case format_: if (*(com->ft)==*(p.com->ft)) return 1; break;      case rPoint_: if (*(com->pt)==*(p.com->pt)) return 1; break;      case rVector_: if (*(com->v)==*(p.com->v)) return 1; break;      case Rect_: if (*(com->rect)==*(p.com->rect)) return 1; break;      case Trixel_: if (*(com->tri)==*(p.com->tri)) return 1; break;      case Trixel2D_: if (*(com->tr)==*(p.com->tr)) return 1; break;      case Poly_: if (*(com->poly)==*(p.com->poly)) return 1; break;      case Poly2D_: if (*(com->ply)==*(p.com->ply)) return 1; break;      case Time_: if (*(com->t)==*(p.com->t)) return 1; break;      case rLine2D_: if (*(com->l)==*(p.com->l)) return 1; break;      case rPoint2D_: if (*(com->p)==*(p.com->p)) return 1; break;      case rLatLon_: if (*(com->ll)==*(p.com->ll)) return 1; break;      case Rect2D_: if (*(com->r)==*(p.com->r)) return 1; break;      case Range_: if (*(com->ra)==*(p.com->ra)) return 1; break;      case Circle2D_: if (*(com->ci)==*(p.com->ci)) return 1; break;      case Null_: if (p.com->type == Null_) return 1;	      break;    }  }  return (0);}int Atom::operator!=(const Atom &p){   return !Atom::operator==(p);}int Atom::operator<=(const Atom &p){    switch (com->type) {      case int_: if (*(com->i)<=*(p.com->i)) return 1; break;      case double_: if (*(com->d)<=*(p.com->d)) return 1; break;      case char_: if (*(com->c)<=*(p.com->c)) return 1; break;      case LitIifsString_:           return 0;      case IifsString_:           return 0;      case Date_: if (*(com->dt)<=*(p.com->dt)) return 1; break;      case Logical_: if (*(com->logic)<=*(p.com->logic)) return 1; break;      case format_: return 0;      case rPoint_: if (*(com->pt)<=*(p.com->pt)) return 1; break;      case rVector_: if (*(com->v)<=*(p.com->v)) return 1; break;      case Rect_: if (*(com->rect)<=*(p.com->rect)) return 1; break;      case Trixel_: if (*(com->tri)<=*(p.com->tri)) return 1; break;      case Trixel2D_: if (*(com->tr)<=*(p.com->tr)) return 1; break;      case Poly_: if (*(com->poly)<=*(p.com->poly)) return 1; break;      case Poly2D_: if (*(com->ply)<=*(p.com->ply)) return 1; break;      case Time_: if (*(com->t)<=*(p.com->t)) return 1; break;      case rLine2D_: return 0;      case rPoint2D_: if (*(com->p)<=*(p.com->p)) return 1; break;      case rLatLon_: if (*(com->ll)<=*(p.com->ll)) return 1; break;      case Rect2D_: if (*(com->r)<=*(p.com->r)) return 1; break;      case Range_: if (*(com->ra)<=*(p.com->ra)) return 1; break;      case Circle2D_: return 0;      case Null_: if (p.com->type <= Null_) return 1;	      break;    }  return (0);}int Atom::operator>=(const Atom &p){    switch (com->type) {      case int_: if (*(com->i)>=*(p.com->i)) return 1; break;      case double_: if (*(com->d)>=*(p.com->d)) return 1; break;      case char_: if (*(com->c)>=*(p.com->c)) return 1; break;      case LitIifsString_:           return 0;      case IifsString_:           return 0;      case Date_: if (*(com->dt)>=*(p.com->dt)) return 1; break;      case Logical_: if (*(com->logic)>=*(p.com->logic)) return 1; break;      case format_: return 0;      case rPoint_: if (*(com->pt)>=*(p.com->pt)) return 1; break;      case rVector_: if (*(com->v)>=*(p.com->v)) return 1; break;      case Rect_: if (*(com->rect)>=*(p.com->rect)) return 1; break;      case Trixel_: if (*(com->tri)>=*(p.com->tri)) return 1; break;      case Trixel2D_: if (*(com->tr)>=*(p.com->tr)) return 1; break;      case Poly_: if (*(com->poly)>=*(p.com->poly)) return 1; break;      case Poly2D_: if (*(com->ply)>=*(p.com->ply)) return 1; break;      case Time_: if (*(com->t)>=*(p.com->t)) return 1; break;      case rLine2D_: return 0;      case rPoint2D_: if (*(com->p)>=*(p.com->p)) return 1; break;      case rLatLon_: if (*(com->ll)>=*(p.com->ll)) return 1; break;      case Rect2D_: if (*(com->r)>=*(p.com->r)) return 1; break;      case Range_: if (*(com->ra)>=*(p.com->ra)) return 1; break;      case Circle2D_: return 0;      case Null_: if (p.com->type >= Null_) return 1;	      break;    }  return (0);}int Atom::operator<(const Atom &p){    switch (com->type) {      case int_: if (*(com->i)<*(p.com->i)) return 1; break;      case double_: if (*(com->d)<*(p.com->d)) return 1; break;      case char_: if (*(com->c)<*(p.com->c)) return 1; break;      case LitIifsString_: return 0;      case IifsString_: return 0;      case Date_: if (*(com->dt)<*(p.com->dt)) return 1; break;      case Logical_: if (*(com->logic)<*(p.com->logic)) return 1; break;      case format_: return 0;      case rPoint_: if (*(com->pt)<*(p.com->pt)) return 1; break;      case rVector_: if (*(com->v)<*(p.com->v)) return 1; break;      case Rect_: if (*(com->rect)<*(p.com->rect)) return 1; break;      case Trixel_: if (*(com->tri)<*(p.com->tri)) return 1; break;      case Trixel2D_: if (*(com->tr)<*(p.com->tr)) return 1; break;      case Poly_: if (*(com->poly)<*(p.com->poly)) return 1; break;      case Poly2D_: if (*(com->ply)<*(p.com->ply)) return 1; break;      case Time_: if (*(com->t)<*(p.com->t)) return 1; break;      case rLine2D_: return 0;      case rPoint2D_: if (*(com->p)<*(p.com->p)) return 1; break;      case rLatLon_: if (*(com->ll)<*(p.com->ll)) return 1; break;      case Rect2D_: if (*(com->r)<*(p.com->r)) return 1; break;      case Range_: if (*(com->ra)<*(p.com->ra)) return 1;break;      case Circle2D_: return 0;      case Null_: if (p.com->type < Null_) return 1;	      break;    }  return (0);}int Atom::operator>(const Atom &p){    switch (com->type) {      case int_: if (*(com->i)>*(p.com->i)) return 1; break;      case double_: if (*(com->d)>*(p.com->d)) return 1; break;      case char_: if (*(com->c)>*(p.com->c)) return 1; break;      case LitIifsString_:           return 0;      case IifsString_:           return 0;      case Date_: if (*(com->dt)>*(p.com->dt)) return 1; break;      case Logical_: if (*(com->logic)>*(p.com->logic)) return 1; break;      case format_: return 0;      case rPoint_: if (*(com->pt)>*(p.com->pt)) return 1; break;      case rVector_: if (*(com->v)>*(p.com->v)) return 1; break;      case Rect_: if (*(com->rect)>*(p.com->rect)) return 1; break;      case Trixel_: if (*(com->tri)>*(p.com->tri)) return 1; break;      case Trixel2D_: if (*(com->tr)>*(p.com->tr)) return 1; break;      case Poly_: if (*(com->poly)>*(p.com->poly)) return 1; break;      case Poly2D_: if (*(com->ply)>*(p.com->ply)) return 1; break;      case Time_: if (*(com->t)>*(p.com->t)) return 1; break;      case rLine2D_: return 0;      case rPoint2D_: if (*(com->p)>*(p.com->p)) return 1; break;      case rLatLon_: if (*(com->ll)>*(p.com->ll)) return 1; break;      case Rect2D_: if (*(com->r)>*(p.com->r)) return 1; break;      case Range_: if (*(com->ra)>*(p.com->ra)) return 1; break;      case Circle2D_: return 0;      case Null_: if (p.com->type > Null_) return 1;	      break;    }  return (0);}Atom& Atom::operator=(const Atom &p){  p.com->ref++;  if (--com->ref == 0) {    com->deletefields ();    delete com;  }  com = p.com;  return *this;}Atom& Atom::operator=(Atom &p){  p.com->ref++;  if (--com->ref == 0) {    com->deletefields ();    delete com;  }  com = p.com;  return *this;}void Atom::atomcopy(Atom &trg,Atom &src){  if (--trg.com->ref == 0) {    trg.com->deletefields ();    delete trg.com;  }  trg.com = new (os_segment::of(this),AREFER) Arefer ();    switch (src.com->type) {      case int_: trg.com->i = new (os_segment::of(this),INT) int (*(src.com->i));  break;      case double_: trg.com->d = new (os_segment::of(this),DOUBLE) double (*(src.com->d));  break;      case char_: trg.com->c = new (os_segment::of(this),CHAR) char (*(src.com->c));  break;      case LitIifsString_: trg.com->s = new (os_segment::of(this),LITSTRING) LitIifsString (); strcpy ((char *)*trg.com->s,(char *) *(src.com->s));  break;      case IifsString_: trg.com->str = new (os_segment::of(this),STRING) IifsString (); strcpy ((char *)trg.com->str,(char *)*src.com->str);  break;      case Date_: trg.com->dt = new (os_segment::of(this),DATE) Date (*(src.com->dt));  break;      case Logical_: trg.com->logic = new (os_segment::of(this),LOGICAL) Logical (*(src.com->logic));  break;      case format_: trg.com->ft = new (os_segment::of(this),fORMAT) format (*(src.com->ft)); break;      case rPoint_: trg.com->pt = new (os_segment::of(this),rPoint) rPoint (*(src.com->pt));  break;      case rVector_: trg.com->v = new (os_segment::of(this),rVector) rVector (*(src.com->v));  break;      case Rect_: trg.com->rect = new (os_segment::of(this),RECT) Rect (*(src.com->rect));  break;      case Trixel_: trg.com->tri = new (os_segment::of(this),TRIXEL) Trixel (*(src.com->tri));  break;      case Trixel2D_: trg.com->tr = new (os_segment::of(this),TRIXEL2D) Trixel2D (*(src.com->tr));  break;      case Poly_: trg.com->poly = new (os_segment::of(this),POLY) Poly (*(src.com->poly));  break;      case Poly2D_: trg.com->ply = new (os_segment::of(this),POLY2D) Poly2D (*(src.com->ply));  break;      case Time_: trg.com->t = new (os_segment::of(this),TIME) Time (*(src.com->t));  break;      case rLine2D_: trg.com->l = new (os_segment::of(this),rLine2D) rLine2D (*(src.com->l)); break;      case rPoint2D_: trg.com->p = new (os_segment::of(this),rPoint2D) rPoint2D (*(src.com->p));  break;      case rLatLon_: trg.com->ll = new (os_segment::of(this),LATLON) rLatLon (*(src.com->ll));  break;      case Rect2D_: trg.com->r = new (os_segment::of(this),RECT2D) Rect2D (*(src.com->r));  break;      case Range_: trg.com->ra = new (os_segment::of(this),RANGE) Range (); trg.com->ra->copy (*(src.com->ra)); cerr <<"atomcopy:"<<*trg.com->ra <<" \n"; break;      case Circle2D_:       case Null_: 	      break;    }  trg.com->type = src.com->type;}Atom& Atom::copy(Atom &src){  if (--com->ref == 0) {    com->deletefields ();    delete com;  }  com = new (os_segment::of(this),AREFER) Arefer ();    switch (src.com->type) {      case int_: com->i = new (os_segment::of(this),INT) int (*(src.com->i));  break;      case double_: com->d = new (os_segment::of(this),DOUBLE) double (*(src.com->d));  break;      case char_: com->c = new (os_segment::of(this),CHAR) char (*(src.com->c));  break;      case LitIifsString_: com->s = new (os_segment::of(this),LITSTRING) LitIifsString (); strcpy ((char *)*com->s,(char *) *(src.com->s));  break;      case IifsString_: com->str = new (os_segment::of(this),STRING) IifsString (); strcpy ((char *)com->str,(char *)*src.com->str);  break;      case Date_: com->dt = new (os_segment::of(this),DATE) Date (*(src.com->dt));  break;      case Logical_: com->logic = new (os_segment::of(this),LOGICAL) Logical (*(src.com->logic));  break;      case format_: com->ft = new (os_segment::of(this),fORMAT) format (*(src.com->ft)); break;      case rPoint_: com->pt = new (os_segment::of(this),rPoint) rPoint (*(src.com->pt));  break;      case rVector_: com->v = new (os_segment::of(this),rVector) rVector (*(src.com->v));  break;      case Rect_: com->rect = new (os_segment::of(this),RECT) Rect (*(src.com->rect));  break;      case Trixel_: com->tri = new (os_segment::of(this),TRIXEL) Trixel (*(src.com->tri));  break;      case Trixel2D_: com->tr = new (os_segment::of(this),TRIXEL2D) Trixel2D (*(src.com->tr));  break;      case Poly_: com->poly = new (os_segment::of(this),POLY) Poly (*(src.com->poly));  break;      case Poly2D_: com->ply = new (os_segment::of(this),POLY2D) Poly2D (*(src.com->ply));  break;      case Time_: com->t = new (os_segment::of(this),TIME) Time (*(src.com->t));  break;      case rLine2D_: com->l = new (os_segment::of(this),rLine2D) rLine2D (*(src.com->l)); break;      case rPoint2D_: com->p = new (os_segment::of(this),rPoint2D) rPoint2D (*(src.com->p));  break;      case rLatLon_: com->ll = new (os_segment::of(this),LATLON) rLatLon (*(src.com->ll));  break;      case Rect2D_: com->r = new (os_segment::of(this),RECT2D) Rect2D (*(src.com->r));  break;      case Range_: com->ra = new (os_segment::of(this),RANGE) Range (); com->ra->copy (*(src.com->ra));  break;      case Circle2D_:       case Null_: 	      break;    }  com->type = src.com->type;  return *this;}Atom& Atom::operator=(int& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = int_;  com->i = new int(t);  return (*this);}Atom& Atom::operator=(double& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = double_;  com->d = new double(t);  return (*this);}Atom& Atom::operator=(char& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = char_;  com->c = new char(t);  return (*this);}Atom& Atom::operator=(const char *t){  //cout <<"Atom::=: Making const char * into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();  }  else {    com->deletefields ();  }  com->type = LitIifsString_;  com->s = new LitIifsString(t);    return *this;}Atom& Atom::operator=(LitIifsString& t){  //cout <<"Atom::=: Making Lit IifsString into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = LitIifsString_;  com->s = new LitIifsString(t);    return (*this);}Atom& Atom::operator=(IifsString& t){  //cout <<"Atom::=: Making  IifsString into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = IifsString_;  com->str = new IifsString(t);    return (*this);}Atom& Atom::operator=(Trixel& t){  //cout <<"Atom::=: Making  Trixel into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Trixel_;  com->tri = new Trixel(t);    return (*this);}Atom& Atom::operator=(Trixel2D& t){  //cout <<"Atom::=: Making  Trixel2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Trixel2D_;  com->tr = new Trixel2D(t);    return (*this);}Atom& Atom::operator=(Poly2D& t){  //cout <<"Atom::=: Making  Poly2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Poly2D_;  com->ply = new Poly2D(t);    return (*this);}Atom& Atom::operator=(Poly& t){  //cout <<"Atom::=: Making  Poly into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Poly_;  com->poly = new Poly(t);    return (*this);}Atom& Atom::operator=(Time& t){  //cout <<"Atom::=: Making  Time into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Time_;  com->t = new Time(t);    return (*this);}Atom& Atom::operator=(rLine2D& t){  //cout <<"Atom::=: Making  rLine2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = rLine2D_;  com->l = new rLine2D(t);    return (*this);}Atom& Atom::operator=(rPoint& t){  //cout <<"Atom::=: Making  rPoint into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = rPoint_;  com->pt = new rPoint(t);    return (*this);}Atom& Atom::operator=(rVector& t){  //cout <<"Atom::=: Making  rVector into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = rVector_;  com->v = new rVector(t);    return (*this);}Atom& Atom::operator=(Rect& t){  //cout <<"Atom::=: Making  Rect into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Rect_;  com->rect = new Rect(t);    return (*this);}Atom& Atom::operator=(rPoint2D& t){  //cout <<"Atom::=: Making  rPoint2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = rPoint2D_;  com->p = new rPoint2D(t);    return (*this);}Atom& Atom::operator=(rLatLon& t){  //cout <<"Atom::=: Making  rLatLon into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = rLatLon_;  com->ll = new rLatLon(t);    return (*this);}Atom& Atom::operator=(Rect2D& t){  //cout <<"Atom::=: Making  Rect2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Rect2D_;  com->r = new Rect2D(t);    return (*this);}Atom& Atom::operator=(Range& t){  cout <<"Atom::=: Making  Range into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Range_;  com->ra = new Range(t);    return (*this);}Atom& Atom::operator=(Circle2D& t){  //cout <<"Atom::=: Making  Circle2D into atom." << t<<" ref"<<com->ref<< '\n'<<flush;  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Circle2D_;  com->ci = new Circle2D(t);    return (*this);}Atom& Atom::operator=(Date& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Date_;  com->dt = new Date(t);  return *this;}Atom& Atom::operator=(Logical& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = Logical_;  com->logic = new Logical(t);  return *this;}Atom& Atom::operator=(format& t){  if (com->ref > 1) {    com->ref--;    com = new  (os_segment::of(this),AREFER) Arefer ();   }  else    com->deletefields ();    com->type = format_;  com->ft = new format(t);  return *this;}