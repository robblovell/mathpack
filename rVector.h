#pragma once#ifndef rVectorhh#define rVectorhh//#include <iostream.h>#include <math.h>//#include <malloc.h>#include "rPoint.h"#include "rVectori.h"#include "rLatLon.h"class rVector;class rVectori;class rLine;class rLatLon;class rMatrix_3_3;/* * Class declaration^ */class rPoint2D;class rVector : public rPoint {	public:    rVector ();   // rVector (rVector &p);    rVector (rPoint2D p);    rVector (rPoint p);    rVector (rPoint A,rPoint B);        rVector (double i,double j,double k);    virtual void set2d (rPoint2D p);    virtual rVector &operator=(rVector p);    virtual rVector &operator=(rPoint p);    virtual rVector &operator=(rVectori p);    virtual rVector &operator=(rPointi p);    virtual rVector &operator=(rPoint2D p);  	virtual rVector &operator=(rLatLon p);    operator double*();	operator rLine ();//	operator rPoint ();        double dot (rVector);    rVector cross (rVector);    double citylen () { return x+y+z; }    double len () { return sqrt (x*x+y*y+z*z); }    double magnitude () { return sqrt (x*x+y*y+z*z); }    void scale (double i) {x*=i; y*=i; z*=i;}	void scale (rVector b);    int near (rVector &v,rVector &n);    int near (rVector &v,double n);    int nearxy (rVector &v,double n);    void normalize ();// {if (iszero()) return;  double len = sqrt (x*x+y*y+z*z); x = x/len; y = y/len; z = z/len; }    rVector normal ();// {if (iszero())return ; double len = sqrt (x*x+y*y+z*z); rVector v(x/len,y/len,z/len); return v;}    void unit ();// { if (iszero())return ; double len = sqrt (x*x+y*y+z*z); x = x/len; y = y/len; z = z/len; }   // rVector rVector () {rVector v(x,y,z); return v;}       rVector operator*(rVector); /* Cross Product */       double operator|(rVector); /* Dot Product */    rVector operator/(rVector); /* Division of rVectors */    rVector operator-(rVector ); /* subtraction of rVectors */    rVector operator+(rVector); /* Addition of rVectors */	 //rVector operator-(rPoint);    // the following five functions can't be handled by gcc.    //rVector operator*(double);     //rVector operator/(double);    //rVector& operator!();     void rVectorize (rVector A,rVector B)    {      x = B.x-A.x; y = B.y-A.y; z = B.z-A.z;     }    // friend rLatLon;/*    friend rVector operator+(rVector ,rPoint );    friend rVector operator+(rPoint ,rVector );    friend rVector operator-(rVector ,rPoint );    friend rVector operator-(rPoint ,rVector );    friend rVector operator+(rVector ,rVector );    friend rVector operator-(rVector ,rVector );    friend double operator|(rVector ,rVector );    friend rVector operator/(rVector ,rVector );    friend rVector operator*(rVector ,rVector );*/    /* gcc requires the & here, sgi /usr/bin/CC can't handle it...!!!*/    friend rVector operator+(double ,rVector );    friend rVector operator+(rVector ,double );    friend rVector operator-(double ,rVector );    friend rVector operator-(rVector ,double );    friend rVector operator*(double ,rVector );    friend rVector operator*(rVector ,double );    friend rVector operator/(double ,rVector );    friend rVector operator/(rVector ,double );    rVector& operator*=(double);    rVector& operator*=(rVector); /* Cross Product */    rVector& operator+=(double);    rVector& operator+=(rVector);    rVector& operator-=(double);    rVector& operator-=(rVector);    rVector& operator/=(double);    rVector& operator/=(rVector);	void abs () { x = ::fabs (x); y = ::fabs (y); z = ::fabs (z); }    int is_obtuse_with (rVector &);    int is_acute_with (rVector &);    int angle_with (rVector );    int angle_with (rVector &,rVector &,rVector &);    int angle_with (rVector &,double&,double&,double&);    // rotation from 0,0,1 around particular axes.     double zrot () {      return atan (y/x);    }    double xrot () {      return atan (z/y);    }    double yrot () {      return atan (x/z);    }    };#endif