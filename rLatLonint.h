#ifndef rLatLoninthh#define rLatLoninthh//#include <iostream.h>#include "rVector.h"#include "rLatLon.h"using std::ostream;/* * Forward class declarations */class rLatLonint;class rLatLon;//class Rect2D;class rPoint2D;class rVector;#define PI		3.141596654#define RADTODEG	180.0/PI#define DEGTORAD	PI/180.0/* * Class declarations */#define PRECISION	100000.0class rLatLonint {  friend ostream& operator<<(ostream&, rLatLonint&); /* used with cout */  protected:  public:    long lon,lat;    rLatLonint () {};    rLatLonint (int i,int j) {lon = (long)((double)i*(double)PRECISION); lat = (long)((double)j*(double)PRECISION);} // just degrees.    rLatLonint (double i,double j) {lon = (long)((double)i*PRECISION); lat = (long)((double)j*PRECISION);}    rLatLonint (rLatLon p) {lon = (long)((double)p.lon*(double)PRECISION); lat = (long)((double)p.lat*(double)PRECISION);}    ~rLatLonint () { };    operator rPoint2D ();    rLatLonint &operator=(rLatLonint );    rLatLonint &operator=(rLatLon );    rLatLonint &operator=(rPoint2D );    int operator==(rLatLonint p) { return (lon == p.lon && lat == p.lat );}    int operator<=(rLatLonint p) { return (lon<=p.lon && lat<=p.lat); }    int operator<(rLatLonint p) { return (lon<p.lon && lat<p.lat); }    int operator>=(rLatLonint p) { return (lon>=p.lon && lat>=p.lat); }    int operator>(rLatLonint p) { return (lon>p.lon && lat>p.lat); }    //operator rVector();    //friend Rect2D;   // friend Trixel;  //  friend rVector;    operator rVector ();    operator rLatLon ();};#endif